{"ast":null,"code":"import _classCallCheck from \"/home/cdz/Code/FrontEnd/algorithm-visualization-for-Mr-Huang/frontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cdz/Code/FrontEnd/algorithm-visualization-for-Mr-Huang/frontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar Graph =\n/*#__PURE__*/\nfunction () {\n  function Graph() {\n    _classCallCheck(this, Graph);\n\n    this.vertices = [];\n    this.adjList = new Map();\n  }\n\n  _createClass(Graph, [{\n    key: \"addVertex\",\n    value: function addVertex(v) {\n      this.vertices.push(v);\n      this.adjList.set(v, []);\n    }\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(v1, v2) {\n      var w = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      this.adjList.get(v1).push({\n        v: v2,\n        w: w\n      });\n      this.adjList.get(v2).push({\n        v: v1,\n        w: w\n      });\n    }\n  }, {\n    key: \"getEdgeWeight\",\n    value: function getEdgeWeight(index1, index2) {\n      var v1 = this.vertices[index1];\n      var v2 = this.vertices[index2];\n      var vs = this.adjList.get(v1);\n      var index = vs.findIndex(function (edge) {\n        return edge.v === v2;\n      });\n      if (index < 0) return Infinity;\n      return vs[index].w;\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(v) {\n      var index = this.vertices.findIndex(function (V) {\n        return V === v;\n      });\n      return index;\n    }\n  }, {\n    key: \"dijkstra\",\n    value: function dijkstra(start, end) {\n      var _this = this;\n\n      start = this.getIndex(start);\n      end = this.getIndex(end);\n      var S = [start];\n      var U = [];\n      var D = [];\n      D[start] = {\n        path: [start],\n        dis: 0,\n        inS: true\n      };\n      var minIndex = start;\n      var disTemp = Infinity;\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        if (i === start) continue;\n        U.push(i);\n        var dis = this.getEdgeWeight(start, i);\n        D[i] = {\n          path: [start, i],\n          dis: dis,\n          inS: false\n        };\n\n        if (disTemp > dis) {\n          disTemp = dis;\n          minIndex = i;\n        }\n      }\n\n      while (U.length > 0) {\n        console.log(minIndex, minIndex);\n        S.push(minIndex);\n        D[minIndex].inS = true;\n        U.splice(U.findIndex(function (v) {\n          return v === minIndex;\n        }), 1);\n        var _dis = D[minIndex].dis;\n        var _disTemp = Infinity;\n        var index = -1;\n\n        for (var _i = 0; _i < U.length; _i++) {\n          var curIndex = U[_i];\n\n          var newDis = _dis + this.getEdgeWeight(minIndex, curIndex);\n\n          if (newDis === Infinity) continue;\n\n          if (newDis < D[curIndex].dis) {\n            D[curIndex].path = [].concat(D[minIndex].path, curIndex);\n            D[curIndex].dis = newDis;\n          }\n\n          if (_disTemp > newDis) {\n            _disTemp = newDis;\n            index = curIndex;\n          }\n        }\n\n        minIndex = index;\n      }\n\n      var path = {\n        path: D[end].path.slice(0),\n        dis: D[end].dis\n      };\n      path.path = path.path.map(function (index) {\n        return _this.vertices[index];\n      });\n      return path;\n    }\n  }]);\n\n  return Graph;\n}();\n\nexport default Graph;\n/*\nlet graph = new Graph();\n\ngraph.addVertex(\"wh\");\ngraph.addVertex(\"cs\");\ngraph.addVertex(\"gy\");\ngraph.addVertex(\"nc\");\n\ngraph.addEdge(\"wh\", \"cs\", 1);\ngraph.addEdge(\"wh\", \"nc\", 6);\ngraph.addEdge(\"wh\", \"gy\", 3);\ngraph.addEdge(\"cs\", \"gy\", 1);\ngraph.addEdge(\"gy\", \"nc\", 3);\n\nlet path = graph.dijkstra(\"wh\", \"gy\");\nconsole.log(path);\n*/","map":{"version":3,"sources":["/home/cdz/Code/FrontEnd/algorithm-visualization-for-Mr-Huang/frontEnd/src/app/component/Graph.js"],"names":["Graph","vertices","adjList","Map","v","push","set","v1","v2","w","get","index1","index2","vs","index","findIndex","edge","Infinity","V","start","end","getIndex","S","U","D","path","dis","inS","minIndex","disTemp","i","length","getEdgeWeight","console","log","splice","curIndex","newDis","concat","slice","map"],"mappings":"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","sourcesContent":["class Graph{\n    constructor(){\n        this.vertices = [];\n        this.adjList = new Map();\n    }\n    addVertex(v){\n        this.vertices.push(v);\n        this.adjList.set(v, []);\n    }\n    addEdge(v1, v2, w=1){\n        this.adjList.get(v1).push({v:v2, w:w});\n        this.adjList.get(v2).push({v:v1, w:w});\n    }\n    getEdgeWeight(index1, index2){\n        let v1 = this.vertices[index1];\n        let v2 = this.vertices[index2];\n        let vs = this.adjList.get(v1);\n        let index = vs.findIndex(edge=>{\n            return edge.v===v2;\n        });\n        if(index<0)return Infinity;\n        return vs[index].w;\n    }\n    getIndex(v){\n        let index = this.vertices.findIndex(V=>{\n            return V===v;\n        });\n        return index;\n    }\n    dijkstra(start, end){\n        start = this.getIndex(start);\n        end = this.getIndex(end);\n        let S = [start];\n        let U = [];\n        let D = [];\n        D[start] = {path:[start], dis:0, inS:true};\n\n        let minIndex = start;\n        let disTemp = Infinity;\n\n        for(let i=0; i<this.vertices.length; i++){\n            if(i===start)continue;\n            U.push(i);\n            let dis = this.getEdgeWeight(start, i);\n            D[i]= {path:[start, i], dis: dis, inS: false};\n            if(disTemp>dis){\n                disTemp = dis;\n                minIndex = i;\n            }\n        }\n\n        while(U.length>0){\n            \n            console.log(minIndex, minIndex);\n            \n            S.push(minIndex);\n            D[minIndex].inS = true;\n            U.splice(U.findIndex(v=>v===minIndex), 1);\n            let dis = D[minIndex].dis;\n\n            let disTemp = Infinity;\n            let index = -1;\n\n            for(let i=0; i<U.length; i++){\n                let curIndex = U[i];\n                let newDis = dis +this.getEdgeWeight(minIndex, curIndex);\n                if(newDis === Infinity)continue;\n                if(newDis<D[curIndex].dis){\n                    D[curIndex].path = [].concat(D[minIndex].path, curIndex);\n                    D[curIndex].dis = newDis;\n                }\n                if(disTemp>newDis){\n                    disTemp = newDis;\n                    index = curIndex;\n                }\n            }\n            minIndex = index;\n        }\n\n        let path ={path:D[end].path.slice(0), dis:D[end].dis};\n        path.path = path.path.map(index=>{\n            return this.vertices[index];\n        });\n        return path;\n    }\n}\nexport default Graph;\n/*\nlet graph = new Graph();\n\ngraph.addVertex(\"wh\");\ngraph.addVertex(\"cs\");\ngraph.addVertex(\"gy\");\ngraph.addVertex(\"nc\");\n\ngraph.addEdge(\"wh\", \"cs\", 1);\ngraph.addEdge(\"wh\", \"nc\", 6);\ngraph.addEdge(\"wh\", \"gy\", 3);\ngraph.addEdge(\"cs\", \"gy\", 1);\ngraph.addEdge(\"gy\", \"nc\", 3);\n\nlet path = graph.dijkstra(\"wh\", \"gy\");\nconsole.log(path);\n*/"]},"metadata":{},"sourceType":"module"}